%%% ALL FUNCTIONS

%% Generate Simple Dubins Path

function [shorterX, shorterY] = compareDubinsPaths(fullX1, fullY1, fullX2, fullY2)

    % Calculate length of first path
    dx1 = diff(fullX1);
    dy1 = diff(fullY1);
    segmentLengths1 = sqrt(dx1.^2 + dy1.^2);
    length1 = sum(segmentLengths1);
    
    % Calculate length of second path
    dx2 = diff(fullX2);
    dy2 = diff(fullY2);
    segmentLengths2 = sqrt(dx2.^2 + dy2.^2);
    length2 = sum(segmentLengths2);

    if length1 < length2
        shorterX = fullX1; shorterY = fullY1;
    else
        shorterX = fullX2; shorterY = fullY2;
    end
end

function [fullX, fullY] = dubinsPathToPosition(start, goalPos, Rmin)
    n = 37;
    for k = linspace(0,360,n)
        goal = [goalPos, deg2rad(k)];

        ds_dub = 1;
        dubConn = dubinsConnection('MinTurningRadius', Rmin);
        cand_fullX = [];
        cand_fullY = [];
        cand_fullTheta = [];
        [segs, ~] = connect(dubConn, start, goal);
        if isempty(segs)
            warning('Dubins connection failed');
            return;
        end
        seg = segs{1};
        s = 0:ds_dub:seg.Length;
        poses = interpolate(seg, s);
        cand_fullX = [cand_fullX; poses(:,1)];
        cand_fullY = [cand_fullY; poses(:,2)];
        cand_fullTheta = [cand_fullTheta; poses(:,3)];

        if k == 0
            fullX = cand_fullX; 
            fullY = cand_fullY;
        else
            [fullX, fullY] = compareDubinsPaths(cand_fullX, cand_fullY, fullX, fullY);
        end
    end
end

%% Simulate LIMO movement

function x = rand_val(a,b)
    x = a + (b-a)*rand;
end

function [xn, yn, thetan] = dubins_step(x, y, theta, omega, v, dt)
% dubins_step  Propagate a Dubins car one step forward
%
% Inputs:
%   x, y, theta  - current pose
%   omega        - turning rate (rad/s)
%   v            - forward velocity
%   dt           - time step (s)
%
% Outputs:
%   xn, yn, thetan - next pose

    xn      = x + v*cos(theta)*dt;
    yn      = y + v*sin(theta)*dt;
    thetan  = theta + omega*dt;
end

function [xn, yn, thetan] = move_dumb_limo(x,y,theta,Rmin,Vmax, dt)
    v = rand_val(0,Vmax);
    omega = rand_val(-v/Rmin, v/Rmin);

    xn      = x + v*cos(theta)*dt;
    yn      = y + v*sin(theta)*dt;
    thetan  = theta + omega*dt;
end


%% PARAMETER DEFININITIONS

start = [0, 0, pi/4];  % Define start: [x, y, theta] where theta is in radians
goal = [-5, -5]; % Define goal: [x, y]
Rmin = 2; % Minimum turning radius
Vmax = 2; % Maximum velocity
commandInterval = 0.1; % Time per command

% Compute path
[fullX, fullY] = dubinsPathToPosition(start, goal, Rmin);

%% INITIALIZE PLOT
figure;

plot(fullX, fullY, 'bo-', 'LineWidth', 2); %plotting the dubins path
hold on;
plot(start(1), start(2), 'go', 'MarkerSize', 10, 'MarkerFaceColor', 'g'); % plot start point
plot(goal(1), goal(2), 'ro', 'MarkerSize', 10, 'MarkerFaceColor', 'r'); % plot end point
axis equal;
grid on;

% Initalize rectangle to represent Limo
L = 2; W = 1;
squareX = [-L/2, L/2, L/2, -L/2];
squareY = [-W/2, -W/2, W/2,  W/2];
hSquare = patch(squareX, squareY, 'blue','DisplayName','LIMO');
hArrow = quiver(0,0,0,0,'LineWidth',2,'Color','r','MaxHeadSize',2, 'DisplayName','Direction');

% Initialize rectangles representing other Limo's
figure; hold on; axis equal
title('Limo squares')

% Pre allocate structure
limo = struct;

limos = 12; % number of other limos

for i = 1:limos
    % start the limos at some random position
    limo_startX = randi([-8 8]);
    limo_startY = randi([-8 8]);
    limo_startTheta = rabdu

    limoX = [-L/2, L/2, L/2, -L/2] + limo_startX;
    limoY = [-W/2, -W/2, W/2,  W/2] + limo_startY;

    R = [cos(newTheta) -sin(newTheta); sin(newTheta) cos(newTheta)];
    rotated = R * [limoX; limoY];

    % Draw square and store handle
    h = fill(limoX, limoY, 'r');  
    set(h, 'DisplayName', sprintf('limo_%d', i));

    % Store handle with dynamic field name
    limo.(sprintf('limo_%d', i)) = h;
end

hold off




xlim([-10 10]);
ylim([-10 10]);
legend('Dubins Path', 'Start', 'Goal');

%% REAL-TIME PLOT UPDATING

for i = 1:1000
    % Update the position of each limo
    for j = 1:limos
        limoID = limo.(sprintf('limo_%d', j));
        xs = get(limoID, 'XData');
        ys = get(limoID, 'YData');
        
        currentX = mean(xs);
        currentY = mean(ys);

        dx = xs(2) - xs(1);
        dy = ys(2) - ys(1);
     
        currentTheta = atan2(dy, dx);

        [newX, newY, newTheta] = move_dumb_limo(currentX, currentY, currentTheta, Rmin, Vmax, commandInterval);;

        R = [cos(newTheta) -sin(newTheta); sin(newTheta) cos(newTheta)];
        rotated = R * [squareX; squareY];

        set(limoID, 'XData', rotated(1,:) + newX, ...
                     'YData', rotated(2,:) + newY);

        disp("X: " + currentX + " Y: " + currentY + " theta: " + currentTheta);

    end
    pause(commandInterval);
end