%%% ALL FUNCTIONS

%% Generate Simple Dubins Path

% Compares two dubins path and returns the shorter one
function [shorterX, shorterY] = compareDubinsPaths(fullX1, fullY1, fullX2, fullY2)

    % Calculate length of first path
    dx1 = diff(fullX1);
    dy1 = diff(fullY1);
    segmentLengths1 = sqrt(dx1.^2 + dy1.^2);
    length1 = sum(segmentLengths1);
    
    % Calculate length of second path
    dx2 = diff(fullX2);
    dy2 = diff(fullY2);
    segmentLengths2 = sqrt(dx2.^2 + dy2.^2);
    length2 = sum(segmentLengths2);

    if length1 < length2
        shorterX = fullX1; shorterY = fullY1;
    else
        shorterX = fullX2; shorterY = fullY2;
    end
end

% creates dubins path
function [fullX, fullY] = dubinsPathToPosition(start, goalPos, Rmin)

    % Inputs:
    %   start = [x,y, theta] of starting position
    %   goalPos = [x,y] of ending position

    n = 37; % number of angles checked;
    for k = linspace(0,360,n)
        goal = [goalPos, deg2rad(k)];

        ds_dub = 1;
        dubConn = dubinsConnection('MinTurningRadius', Rmin);
        cand_fullX = [];
        cand_fullY = [];
        cand_fullTheta = [];
        [segs, ~] = connect(dubConn, start, goal);
        if isempty(segs)
            warning('Dubins connection failed');
            return;
        end
        seg = segs{1};
        s = 0:ds_dub:seg.Length;
        poses = interpolate(seg, s);
        cand_fullX = [cand_fullX; poses(:,1)];
        cand_fullY = [cand_fullY; poses(:,2)];
        cand_fullTheta = [cand_fullTheta; poses(:,3)];

        if k == 0
            fullX = cand_fullX; 
            fullY = cand_fullY;
        else
            [fullX, fullY] = compareDubinsPaths(cand_fullX, cand_fullY, fullX, fullY);
        end
    end
end

%% Helper functions

% returns a random value between a and b
function x = rand_val(a,b)
    x = a + (b-a)*rand;
end

% pointDistance  Compute Euclidean distance between (x1,y1) and (x2,y2)
function d = dist(x1, y1, x2, y2)
    d = sqrt( (x2 - x1)^2 + (y2 - y1)^2 );
end

%% Simulate LIMO movement
function [xn, yn, thetan] = dubins_step(x, y, theta, omega, v, dt)
% dubins_step  Propagate a Dubins car one step forward
%
% Inputs:
%   x, y, theta  - current pose
%   omega        - turning rate (rad/s)
%   v            - forward velocity
%   dt           - time step (s)
%
% Outputs:
%   xn, yn, thetan - next pose

    xn      = x + v*cos(theta)*dt;
    yn      = y + v*sin(theta)*dt;
    thetan  = theta + omega*dt;
end


function [xn, yn, thetan] = move_dumb_limo_sim(x,y,theta,Rmin,Vmax, dt)
    % controls limos to move randomly
    v = rand_val(0,Vmax);
    omega = rand_val(-v/Rmin, v/Rmin);

    xn      = x + v*cos(theta)*dt;
    yn      = y + v*sin(theta)*dt;
    thetan  = theta + omega*dt;
end

function [v, omega] = bot_step_sim(limoX, limoY, limoTheta, targetX, targetY, Vmax, Rmin, atGoal)

    % bot_step_sim returns the v and omega the bot requires to move towards
    % target point
    %
    % Inputs:
    %   limoX, limoY, limoTheta - current LIMO pose
    %   targetX, targetY        - target position
    
    %% ----------------- CONFIG (based on physical parameters of LIMO and default values that we found were effective) -----------------
    omegaMax = Vmax/Rmin;    % max angular velocity (rad/s)
    Kp_linear = 1.0;   % proportional gain for linear velocity
    Kp_angular = 2.0;  % proportional gain for angular velocity
    
    %% ----------------- COMPUTE ERRORS -----------------
    dx = targetX - limoX;
    dy = targetY - limoY;
    distance = sqrt(dx^2 + dy^2);
    
    desiredTheta = atan2(dy, dx);
    angleError = wrapToPi(desiredTheta - limoTheta);
    
    %% ----------------- CHECK IF AT GOAL -----------------
    if atGoal
        v = 0;
        omega = 0;
    else
        % Proportional control
        v = Kp_linear * distance;
        omega = Kp_angular * angleError;
        
        % Limit velocities
        v = max(min(v, Vmax), -Vmax);
        omega = max(min(omega, omegaMax), -omegaMax);
    end
end

%% COLLISION AVOIDANCE
function intersects = quiverIntersectsLine(hQuiver, lineX, lineY)
% quiverIntersectsLine  Check if a quiver intersects a piecewise line
%
% Inputs:
%   hQuiver - handle to quiver object
%   lineX   - vector of x coordinates of piecewise line
%   lineY   - vector of y coordinates of piecewise line
%
% Output:
%   intersects - true if the quiver intersects any segment of the line

    % Get quiver data
    x0 = hQuiver.XData;
    y0 = hQuiver.YData;
    u  = hQuiver.UData;
    v  = hQuiver.VData;

    % Quiver endpoint
    x1 = x0 + u;
    y1 = y0 + v;

    intersects = false;

    % Check each segment of the piecewise line
    for i = 1:length(lineX)-1
        % segment endpoints
        x2 = lineX(i);
        y2 = lineY(i);
        x3 = lineX(i+1);
        y3 = lineY(i+1);

        if segmentsIntersect(x0,y0,x1,y1,x2,y2,x3,y3)
            intersects = true;
            return
        end
    end
end

% -----------------------
function flag = segmentsIntersect(x1,y1,x2,y2,x3,y3,x4,y4)
% Check if line segment (x1,y1)-(x2,y2) intersects (x3,y3)-(x4,y4)
    
    % Compute denominators
    den = (x1-x2)*(y3-y4) - (y1-y2)*(x3-x4);
    if den == 0
        flag = false; % parallel
        return
    end

    % Compute intersection point t and u
    t = ((x1-x3)*(y3-y4) - (y1-y3)*(x3-x4)) / den;
    u = -((x1-x2)*(y1-y3) - (y1-y2)*(x1-x3)) / den;

    % Check if intersection is within both segments
    flag = (t >= 0 && t <= 1 && u >= 0 && u <= 1);
end

%% PARAMETER DEFININITIONS (CONFIG)

start = [10, 7, 0];  % Define start: [x, y, theta] where theta is in radians
goal = [-8, -8]; % Define goal: [x, y]
Rmin = 2; % Minimum turning radius
Vmax = 2; % Maximum velocity
commandInterval = 0.1; % Time per command


limos = 12; % number of other limos

lookOutDist = 5; % how many checkpoints ahead the limo looks to see if anything is in it's path
tol = 0.5; % how close to point to be considered 'at' the point
recalDist = 5; % how far from goal point to recalibrate path


%% INITIALIZE PLOT

% Compute path
[fullX, fullY] = dubinsPathToPosition(start, goal, Rmin);

figure;

plot(fullX, fullY, 'bo-', 'LineWidth', 2); %plotting the dubins path
hold on;
plot(start(1), start(2), 'go', 'MarkerSize', 10, 'MarkerFaceColor', 'g'); % plot start point
plot(goal(1), goal(2), 'ro', 'MarkerSize', 10, 'MarkerFaceColor', 'r'); % plot end point
axis equal;
grid on;

% Initalize rectangle to represent Limos; L = limo length, W = limo width
L = 2; W = 1;
limoX = [-L/2, L/2, L/2, -L/2];
limoY = [-W/2, -W/2, W/2,  W/2];

% Initialize our 'bot' which is the LIMO we control
hBot = patch(limoX + start(1), limoY + start(2), 'blue','DisplayName','LIMO');


%% INITIALIZE ALL OTHER LIMOS
% Pre allocate structure
limo = struct;

for i = 1:limos
    % start the limos at some random position
    limo_startX = randi([-8 8]);
    limo_startY = randi([-8 8]);
    limo_startTheta = randi([0 360]);

    % limoX = [-L/2, L/2, L/2, -L/2];
    % limoY = [-W/2, -W/2, W/2,  W/2];

    R = [cos(limo_startTheta) -sin(limo_startTheta); sin(limo_startTheta) cos(limo_startTheta)];
    rotated = R * [limoX  + limo_startX; limoY + limo_startY];

    % Draw square and store handle
    h = fill(rotated(1,:), rotated(2,:), 'y');
    
    hArrowA = quiver(0,0,0,0,'LineWidth',2,'Color','g','MaxHeadSize',0.5, 'DisplayName','Direction');
    hArrowB = quiver(0,0,0,0,'LineWidth',2,'Color','g','MaxHeadSize',0.5, 'DisplayName','Direction');
    set(h, 'DisplayName', sprintf('limo_%d', i));
    set(hArrowA, 'DisplayName', sprintf('arrow_%d_a', i));
    set(hArrowB, 'DisplayName', sprintf('arrow_%d_b', i));

    % Store handle with dynamic field name
    limo.(sprintf('limo_%d', i)) = h;
    limo.(sprintf('arrow_%d_a', i)) = hArrowA;
    limo.(sprintf('arrow_%d_b', i)) = hArrowB;
end

% Choose Graph Size (change to fit to match RASTIC's mocap area)
xlim([-20 20]);
ylim([-20 20]);

%% REAL-TIME PLOT UPDATING FOR SIMULATION (MAIN LOOP)

% Pre-loop initializations
atGoal = 0; % atGoal is 0 if bot not at goal, 1 if it is
intersection = 0; % initialize boolean checking fi there is a limo in the immediate path
targetPointNum = 1; % initalize which poin the Limo is trying to go

while ~atGoal

    % get bot current position (SIMULATION)
    xs_bot = get(hBot, 'XData');
    ys_bot = get(hBot, 'YData');

    cx_bot = mean(xs_bot);
    cy_bot = mean(ys_bot);

    dx_bot = xs_bot(2) - xs_bot(1);
    dy_bot = ys_bot(2) - ys_bot(1);
 
    ct_bot = atan2(dy_bot, dx_bot);

   
    % Choose Target Point based on position and check if path recalibration
    % needed

    targetX = fullX(targetPointNum);
    targetY = fullY(targetPointNum);
    if dist(cx_bot, cy_bot, targetX, targetY) < tol
        targetPointNum = targetPointNum + 1;
    end
    if(targetPointNum >= length(fullX))
        atGoal = 1;
        targetPointNum = targetPointNum - 1;
    end
    % recalibrate path
    if dist(cx_bot, cy_bot, targetX, targetY) > recalDist
        currentPos = [cx_bot, cy_bot, ct_bot];
        [fullX, fullY] = dubinsPathToPosition(currentPos, goal, Rmin);
        targetPointNum = 1;
    end


    if(targetPointNum + lookOutDist >= length(fullX))
        lookOutX = fullX(targetPointNum: end);
        lookOutY = fullY(targetPointNum: end);
    else
        lookOutX = fullX(targetPointNum:targetPointNum + lookOutDist);
        lookOutY = fullY(targetPointNum:targetPointNum + lookOutDist);
    end
    plot(fullX, fullY, 'bo-', 'LineWidth', 2); %plotting the dubins path
    plot(lookOutX, lookOutY, 'ro-', 'LineWidth', 2); %plotting the dubins path
    
    if intersection
        v_bot = 0; omega_bot = 0;
    else
        [v_bot, omega_bot] = bot_step_sim(cx_bot, cy_bot, ct_bot, targetX, targetY, Rmin, Vmax, 0);
    end

    [newX_bot, newY_bot, newTheta_bot] = dubins_step(cx_bot, cy_bot, ct_bot, omega_bot, v_bot, commandInterval);

    R = [cos(newTheta_bot) -sin(newTheta_bot); sin(newTheta_bot) cos(newTheta_bot)];
    rotated_bot = R * [limoX; limoY];

    % U
    set(hBot, 'XData', rotated_bot(1,:) + newX_bot, ...
                 'YData', rotated_bot(2,:) + newY_bot);

    % Update the position of each dumb limo
    intersection = 0;
    for j = 1:limos
        limoID = limo.(sprintf('limo_%d', j));
        arrowID_a = limo.(sprintf('arrow_%d_a', j));
        arrowID_b = limo.(sprintf('arrow_%d_b', j));
        xs = get(limoID, 'XData');
        ys = get(limoID, 'YData');
        
        currentX = mean(xs);
        currentY = mean(ys);

        dx = xs(2) - xs(1);
        dy = ys(2) - ys(1);
     
        currentTheta = atan2(dy, dx);

        [newX, newY, newTheta] = move_dumb_limo_sim(currentX, currentY, currentTheta, Rmin, Vmax, commandInterval);;

        R = [cos(newTheta) -sin(newTheta); sin(newTheta) cos(newTheta)];
        rotated = R * [limoX; limoY];

        set(limoID, 'XData', rotated(1,:) + newX, ...
                     'YData', rotated(2,:) + newY);

        % Compute back edge midpoint in local rectangle coordinates
        bottomLeft_local = [-L/2; -W/2];  % x = -L/2 is back edge, y = 0 is center of edge
        bottomRight_local = [-L/2; W/2];
        
        % Rotate back edge midpoint according to newTheta
        bottomLeft_world = R * bottomLeft_local;
        bottomRight_world = R * bottomRight_local;
        
        % Translate to new rectangle position
        backX_a = bottomLeft_world(1) + newX;
        backY_a = bottomLeft_world(2) + newY;

        backX_b = bottomRight_world(1) + newX;
        backY_b = bottomRight_world(2) + newY;


        % Arrow length (tweak as needed)
        arrowLength = 5;  
        
        % Arrow direction in world coordinates
        arrow_dx = arrowLength * cos(newTheta);
        arrow_dy = arrowLength * sin(newTheta);
        
        % Update arrow position and direction
        set(arrowID_a, 'XData', backX_a, ...
                    'YData', backY_a, ...
                    'UData', arrow_dx, ...
                    'VData', arrow_dy);

        set(arrowID_b, 'XData', backX_b, ...
                    'YData', backY_b, ...
                    'UData', arrow_dx, ...
                    'VData', arrow_dy);

       % disp("X: " + currentX + " Y: " + currentY + " theta: " + currentTheta);

       %check for intersection
       if quiverIntersectsLine(arrowID_a, lookOutX, lookOutY) || quiverIntersectsLine(arrowID_b, lookOutX, lookOutY)
           intersection = 1;
           set(arrowID_a, 'Color', 'r');
           set(arrowID_b, 'Color', 'r');
       else
           set(arrowID_a, 'Color', 'g'); % Reset color if no intersection
           set(arrowID_b, 'Color', 'g'); % Reset color if no intersection
       end
    end
    
    pause(commandInterval);
    legend('Dubins Path', 'Start', 'Goal');
end

disp("PATH COMPLETE!")